---
title: 'Multithreading'
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '/blog-placeholder-3.jpg'
---

A pesar de que el código de javascript como tal si que se ejecuta en un solo hilo, node no es single-threaded. Los worker threads se implementaron en node 12 (2019)

Los procesos tienen tres estados, ready, running y sleep. Un proceso entra en estado sleep cuando el proceso está esperando a algo, cuando ese evento ocurre, el estado se vuelve a cambiar a ready. Un ejemplo sería esperar una petición en un puerto determinado o esperar un input del teclado o un click. Otro estado es suspended, se da cuando el proceso se encuentra en estado de sleep durante un tiempo prolongado y el sistema operativo lo mueve de la RAM al disco duro, proceso conocido com swap.

##### CONCURRENCIA Y CPU
El término concurrencia hace referencia a la ejecución de varios procesos al mismo tiempo, pero no de manera simultánea, sino que se ejecutan al mismo tiempo debido a los cambios de contexto, dando la ilusión de simultaneidad. El paralelismo se da cuando los procesos se ejecutan exactamente al mismo tiempo. Un hilo es una unidad de ejecución y su creación es mucho mas rápida que la creación de un proceso totalmente nuevo, además, compartir un espacio de memoria entre hilos es mucho más sencillo que entre procesos y no se involucra al sistema operativo.

Se puede saber la cantidad de núcleos totales (contando lógicos) que tiene el sistema con la función os.availableParallelism() de Node. El comando ps sin argumentos muestra los procesos abiertos por la consola actual, para ver todos los procesos del sistema se usa la flag -A. Se puede saber la cantidad de hilos que tiene un proceso con el comando ps -o (de output) thcount [PID]

Al usar top, éste por defecto se ejecuta en modo 1, en este método, un proceso puede ocupar el 100% de CPU ya que muestra el porcentaje de uso por núcleo, no el total. Pulsando shift i, se cambia de modo al 2, que muestra el procentaje sobre el total de capacidad. Si por ejemplo un proceso usaba el 100% y la máquina tiene 4 núcleos, ahora mostrará el 25%. 

##### WORKER THREADS
Para crear un nuevo hilo con Node se usa la clase Worker, que se importa del módulo ‘worker_threads’. Se crea una instancia de la clase y se le pasa como parámetro el archivo a ejecutar, en este caso de javascript. Las variables y funciones definidas en ambos archivos son independientes y pueden llamarse igual sin que haya conflictos. Además, cada hilo tiene su propio event loop. Cuando se imprime algo en consola en los hilos hijos, pasa a la consola del padre, debido a que los input y output estándar están conectados, por lo que si se bloquea el hilo principal, no se verá nada en consola. Crear nuevos hilos es mas rápido que crear nuevos procesos.

Al inicializar la instancia de la clase Worker, se puede pasar un objeto como segundo parámetro. Una de sus propiedades es workerData. En el archivo del hilo hijo se debe importar workerData, y de esta manera puede acceder a la información que se ha enviado desde el hilo principal.

Lo que se hace es crear una copia de la data serializando y deserializando la información con la función v8.serialize() y v8.deserialize()

##### COMUNICACIÓN ENTRE PROCESOS
Para la comunicación entre procesos se utiliza una instancia de la clase MessageChannel, que tiene una propiedad port1 y port2. Se envía un mensaje desde un puerto con el método postMessage() y en el otro puerto se escucha el evento message. Ambos puertos pueden emitir y recibir mensajes. Desde el hilo principal se puede enviar un puerto a un worker thread mediante el objeto workerData. Se pueden crear múltiples instancias de MessageChannel y poner en contacto varios hilos. En este caso la información enviada a través de los puertos no son buffers sino javascript. Para que esto funcione se debe especificar una segunda propiedad en el constructor del Worker. Se trata de transferList, un array que debe contener los puertos que se transfieren. Si esto no se hace el programa lanzará un error, debido a que una vez que se transfieren los puertos a los hilos worker, los puertos no deberían seguir siendo accesibles desde el hilo principal. En transferList solo se pueden pasar buffers, puertos y manejadores de archivos. No es posible pasar objetos de javascript. Lo que hace la propiedad tranferList es cambiar la propiedad del objeto pasado del hilo principal al hilo hijo, esto siginifica que el hilo principal no podrá usar los puertos para enviar mensajes. 

Node ofrece una forma mas sencilla de comunicarse entre hilos, aunque en realidad utiliza el proceso anterior por detrás. Simplemente se crea el hilo nuevo, y en ese hilo se escucha el evento message. Para enviar se utiliza también el método postMessage(), pero en este caso es un método del objeto parentPort, que se debe importar. Es una forma mas sencilla de hacerlo aunque se pierde algo de control. Para leer la información desde el hilo hijo se importa el objeto parentPort, que puede escuchar el evento message y usar el método postMessage().

##### BUENAS PRÁCTICAS
El uso de worker threads es una buena solución para llevar a cabo tareas de computación intensivas sin bloquear el hilo principal. Cuando se termina la ejecución en el hilo, simplemente se devuelve el resultado al hilo principal. Generalmente a la hora de generar hilos, se define su cantidad de manera dinámica leyendo una variable de entorno, ya que cada máquina tiene una cantidad de núcleos distinta.

Cuando se usa el multithreading es recomendable probar con valores extremos, ya que pueden producirse efectos que no se producen con valores pequeños, por ejemplo, al usar big ints, se puede producir un cuello de botella por la necesidad de asignación de memoria.

No es una buena práctica crear un hilo nuevo para cada petición que requiera de computación intensiva, ya que podría ser una vulnerabilidad frente a ataques. Un patrón a la hora de trabajar con miltithreading es contar con un threadpool, generalmente acorde con la cantidad de núcleos disponibles. En caso de que la operación tarde demasiado es recomendable establecer un tiempo máximo para ello y si no se ha completado en ese periodo de tiempo, terminar el hilo y devolver un código 408. Esto se hace con la función setTimeOut(). En caso de que si se haya completado se debe cancelar el temporizador con la función clear(). Para poder reutilizar el mismo código sin generar nuevos hilos de manera recursiva, se usa la propiedad isMainThread. 

Para saber el id de un hilo es necesario importar threadId del módulo worker_thread. Este módulo es de gran ayuda a la hora de trabajar con operaciones muy intensivas con el CPU pero no tanto con operaciones intensivas de I/O, en este caso lo ideal es usar las funciones asíncronas que _Node provee.

Para evitar llamar muchas veces a una función, lo que se puede hacer es batching, por ejemplo, en el caso de llenar un buffer con números aleatorios usando la función randomFillSync() del módulo crypto. Suponinendo que los números son íntegros de 16 bits, en vez de crear un buffer de 16 bits y llenarlo con un valor aleatorio con la función anterior, batching consistiría en crear un buffer mayor, por ejemplo de 4096 bits, llenarlo en una sola llamada a la función y luego leer los bytes de dos en dos, usando un offset mediante el método buffer.readUInt16BE
(offset). Este método solo lee 16 bits y empieza a hacerlo desde el offset indicado, por lo que ahora simplemente se ejecuta dentro de un bucle y en cada iteración se incrementa el offset en 2 bytes. Esto mejora el rendimiento ya que la función randomFillSync() bloquea la ejecución del código y en términos de rendimiento, es preferible llamarla menos veces consiguiendo el mismo resultado. Esto actúa el como cuello de botella, y aunque se usen mas hilos, el porcentaje de uso de la CPU no aumenta en consecuencia de la cantidad de hilos (8 hilos en un CPU de 8 núcleos debería ser cercano a 800%)

Al usar worker threads para ejecutar tareas largas, una buena práctica es usar promesas. Se crea una nueva promesa y dentro de ella se crea el hilo, al hilo se le pasa la información usando la propiedad workerData del segundo parámetro. Se espera al resultado escuchando mediante el evento ‘message’ y cuando esto ocurre se ejecuta la función resolve() de la promesa para devolver el resultado obtenido. También se escucha el evento ‘error’, en cuyo caso se ejecutará la función reject(). En el proceso hijo se recibe la data mediante la propiedad workerData y se envía al padre el resultado mediante el método parentPort.postMessage(). Esta es una mejor alternativa que usar setInmediate().

##### THREADPOOL
Node provee un threadpool de 4 hilos a los cuales no se puede acceder directamente, sino que se usan a través de las funciones asincronas y promesas. Aunque se puede cambiar la cantidad de hilos del pool modificando la variable de entorno UV_THREADPOOL_SIZE. En caso de haber más operaciones que realizar que hilos disponibles, se crea una cola y se van ejecutando a medida que se completan las anteriores.

Mientras que el event loop opera en el hilo principal, el threadpool consta de worker threads responsables de ejecutar tareas que requieren mucho tiempo de forma asíncrona. Las tareas que se pueden descargar al threadpool incluyen operaciones de E/S de archivos, funciones criptográficas y otras operaciones que requieren un uso intensivo de la CPU.