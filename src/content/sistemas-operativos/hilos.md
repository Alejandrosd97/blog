---
title: 'Hilos'
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '/algoritmo.svg'
---

El stack también se conoce como memoria estática y el heap como memoria dinámica. La cantidad de memoria que debe ser asignada para el stack es fija y se decide en tiempo de compilación, no se puede modificar en tiempo de ejecución. La memoria para el heap se asigna en tiempo de ejecución y generalmente se usa para almacenar estructuras de datos como listas enlazadas o colas. El stack puede ser accedido por el la sección del código, pero el heap no. Para acceder al heap se debe acceder primero al stack y se encuentra un puntero con la dirección de inicio necesaria, y es a través de esa dirección que se accede al heap.

Un hilo de ejecución es la secuencia más pequeña de instrucciones programadas que un scheduler puede gestionar de forma independiente. En muchos casos, un hilo es un componente de un proceso. Un mismo programa puede tener diferentes secuencias de ejecución debido a los bucles o las sentencias condicionales, que alteran el flujo de ejecución. Cada una de estas secuencias de ejecución es un hilo. Los procesos son por defecto single-threaded. Debido a que cada proceso es una copia del mismo programa esto genera dos desventajas. La primera es que se realizan numerosos cambios de contexto, perdiendo mucho tiempo por el camino y la segunda es el desperdicio de memoria ya que se están guardando dos copias del mismo código. Estos dos inconvenientes pueden ser eliminados mediante la implantación de procesos multihilo. En este caso se mantiene un solo PCB cuyo código  puede ser ejecutado en diferentes secuencias. El heap y data también son comunes a los diferentes hilo, no así el stack y el set de registros, manteniendo uno diferente para cada hilo. El motivo por el que el heap se mantiene compartido es que puede ser que un hilo necesitee acceso a información qu otro hilo del mismo proceso ya ha buscado y cargado en le RAM, de esta manera, el segundo proceso puede leer la data sin necesidad buscarla y cargarla nuevamente. El stack no lo es porque el orden de ejecución de las funciones depende del flujo del programa, que varía para cada hilo

Todos los procesos se inician con un solo hilo y se crean hilos adicionales según se necesiten. Por ejemplo en un servidor web, cada vez que un cliente realiza una petición se crea un nuevo proceso que sirve a ese cliente, cada uno de estos procesos sigue una secuencia de ejecución diferente acorde a la petición del cliente. 

La ventaja de los procesos multihilo respecto de fork() es que se ahorra memoria, ya que fork() crea un proceso single-threaded nuevo cada vez

##### MULTITHREADING
La otra ventaja del multihilo es la simplicación de los cambios de contexto. Los hilos se pueden crear a nivel de usuario o de kernel. En el caso del hilos a nivel de usuario se crean mediante una funcíon presente en el código que se ejecutará en caso de ser necesario crear un hilo. En el caso de los hilos a nivel de kernel, se lleva a cabo la creación del hilo mediante una llamada al sistema. Debido a la necesidad de cambiar de modo a modo de kernel, los hilos de usuario son mucho más rápidos de crear. En el caso de los hilos de usario, el acmabio de contexto no lo lleva a cabo el scheduler del sistema operativo sino una funcíon dentro del código del proceso, lo cual, una vez más es más rápido al evitar un cambio de modo. Si los hilos son de usuario, el kernel no tiene manera de saber cuantos hilos existen, por lo que el tiempo que se concede a cada proceso para ejecutarse en algunos algoritmos como roud robin, no tendrá en cuenta la cantidad de hilos de cada proceso. Es decir, proceso con 10 hilos dispondrá del mismo tiempo que otro proceso con un solo hilo. Esta es la desventaja de los procesos de usuario, de la misma manera, cunado uno de los hilos de usuario de un proceso esté llevando a cabo operaciones de input/output, como el sistema operativo no tiene conocimiento de estos hilos bloqueará el proceso entero y el resto de hilos no se ejecutarán hasta que termine el input/output. Esto no ocurre con los hilos de kernel, se puede considerar que en el caso de los hilos de kernel, el scheduler no hace scheduling de procesos sino de hilos