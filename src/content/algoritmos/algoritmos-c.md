---
title: 'Algoritmos en C'
id: 1
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '/binary.svg'
---


##### STACK
Es un tipo de estructura de datos lineal en la cual los elementos solo pueden ser añadidos o eliminados en la parte superior, es decir sigue un orden LIFO, Last In First Out. Esto significa que los elementos se eliminan en orden inverso al orden en el que se añaden, los últimos se eliminan los primeros. El proceso de inserción se conoce como push y la eliminación como pop. Se dice que el stack se encuentra en estado de overflow cuando está lleno, por lo no admite push de más elementos, y underflow cunado el stack está vacío, por lo que es la operación pop la que no está permitida. Un ejemplo de stack sería la operación deshacer de los editores de texto, que eliminan del stack los últimos cambios aplicados al texto, o el botón de atrás del navrgador.

Se puede crear un stack mediante el uso de un array unidomensional. Para ello se crea una variable llamada top, la cual guarda el índice del último elemento del array, para poder hacer operaciones push y pop sobre el array. Al crear el array se suele inicializar la variable con el valor -1, ya que no hay ningún elemento en el array y se va incrementando de uno en uno conforme se va haciendo push de elementos. Para que no ocurra un error de stack overflow, antes de realizar el push de un elemento, se debe comprobar que el valor de top es menor que el tamaño del array – 1. Es decir que si el array tiene capacidad para 10 elementos, el valor de top debe ser menor a 9. Para hacer pop, los pasos siguen el orden inverso, primero se comprueba que el valor de top sea igual o mayor que 0, es decir que el stakc no se encuentra en estado de underflow. En caso afirmativo, se elimina el elemento en el índice correspondiente al valor de top del stack y se decrementa en 1 el valor de top 

##### COLA
Una cola es una estructura de datos lineal que sigue el orden FIFO (First In First Out). El elemento añadido primero es elminado primero. Al contrario que el stack, la cola tiene dos terminaciones, la delantera, de donde se eliminan los elementos y la trasera, que es donde los elementos se insertan. No obstante, existen otros tipos de cola como la cola con prioridad. Este tipo de cola sería mejor implemntada una estructura de datos heap.

Para implementar una cola usando un array unidimensional, se declaran dos variables, una para el front, correspondiente a la terminación delantes y que indica el el índice del siguiente elemento que debe ser eliminado, y otra para el rear, la cual indicará en que índice se añade el nuevo elemento. Tanto front como rear se inicializan como 0, lo cual indica que la cola está vacía, lo que al igual que en el stack se conoce como underflow. Por el contrario, overflow ocurrirá cuando el valor de rear sea igual al tamaño del array, es decir, supere el último índice. La adición de un elemento se conoce como enqueue y la eliminación como dequeue. Según se van eliminado elemntos de la cola, va quedando espacio libre al usar al inicio, para mientra que el espacio al final se va anotando. Debido a esto puede ocurrir un error de overflow habiendo mucho espacio vacío en la cola o incluso un error de underflow si las dos variables front y rear se encuentran en el último índice de la cola, a pesar de estar completamente vacía. Para que esto no ocurra la implementación de la cola debe ser circular.

En la cola circular las variables front y rear se inicializan con el valor -1, es decir, el último elemento del array. Para la operación equeue se suma uno al valor de rear y se divide entre la longitud del array. El resto será el índice en el que se insertará el elemento. Por ejemplo, en un array de 10 elementos, el primero será:  ( 9+1) % 10, en este caso el resto es 0 y el elemento se añade en el índice 0, el segundo (0 + 1) % 10 y se insertará en el valor del módulo, que es 1. En este caso, la condición para que se de overflow es que el índice del rear + 1  sea igual al del front, es decir, que el siguiente elemento esté en el índice del front.

Para números positivos, siempre que el divisor es mayor que el dividendo, el resto es igual al dividendo.

Una cola de doble terminación es aquella que permite inserción y eliminación en sus dos extremos. No se puede insertar elementos en el front si éste se encuentra en índice 0.

##### LINKED LIST
Usar un array como estructura de datos presenta algunas desventajas. La primera es el tamaño del array, esto puede suponer una limitación y además no es una buena idea cambiar el tamaño de un array en tiempo de ejecución. Otro problema que presenta este enfoque es la imposibilidad de eliminar un elemento que se encuentre entre el primer y último índice de los elementos existentes, es decir, que no sea el índice correspondiente a rear o front. Sería necesario correr todos los elementos hasta que el elemento a eliminar quede en el índice del front. A pesar de ser posible mediante el uso de bucles, esto tendría un impacto muy grande sobre el rendimiento. Y pasaría lo mismo con la adición.

A diferencia de un array donde las direcciones de los elementos son continuas, de ahí que se pueda saltar al índice previo o posterior incrementando la dirección base, las direcciones de memoria de los link list son asignadas de manera dinámica usando la función malloc(). Esto imposibilita hacer recorrer los elementos incrementando las direcciones, puesto que no son contiguas. Además el acceso aleatorio a los nodos tampoco es posible. Por ello, cada elemento dentro de la link list consiste en dos partes, un valor y un puntero con la dirección del siguiente elemento en la lista. Además es necesario un puntero que apunte a la dirección del primer elemento de la lista y uno que apunte al último. Cada elemento dentro de la lista se conoce como nodo y el último nodo de la lista contiene un puntero con el valor null, para indicar que es el último. Existen varios tipos de link list, en las listas circulares, no existe un puntero para el primer elemento. El puntero next del último elemento apunta al primero creando un flujo circular. Si existe un puntero que guarda la dirección del último elemento y que puede ser usado para saber la dirección del primero puesto que ésta se encuentra en el último nodo. Otro tipo es la link list doble, en la que cada nodo contiene dos punteros, uno para dirección siguiente y otro para la anterior. En este caso el puntero de la dirección previa del primer elemento y el de la dirección siguiente del último tienen el valor NULL. Este tipo permite navegar por la lista en ambas direcciones.

###### Single linked list
Para insertar un nodo en la cola (final), si esta está vacía se copia la dirección de ese primer nodo al puntero head y tail, que hasta ahora eran null. Si ya existen nodos, se copia la dirección del nodo que se añade al final y se copia en el puntero next del que era hasta ahora el último nodo. Tambíen se actualiza la dirección del puntero tail para que apunte al nodo que se ha añadido. Para añadir un puntero al inicio, el procedimiento es el mismo, solo que se actualiza el puntero head en vez de tail y se coloca la dirección del nodo hasta ahora primero en el puntero next del nodo nuevo

##### RECURSIÓN
Para llevar a cabo una tarea repetitiva se pueden usar bucles o recursión. Si una función se llama a si misma se trata de una función recursiva. Para que no se cree un bucle infinito debe haber una condición base, que de cumplirse termine con la ejecución. Cada nueva llamada crea una instancia diferente de la función, por lo que si se modifica una variable declarada dentro de la función, debido a que esta es local, no se verán los cambios en la siguiente llamada. Para evitar esto, se puede declarar la variable como static, lo que significa que va a existir durante toda la vida del programa.

Para que el número de veces que se ejecuta la función sea dinámico, se define esa cantidad de veces mediante un parámetro n y cuando se vuelve a llamar la función dentro se para como argumento n – 1. En este caso, se debe especificar la condición base para que termine cuando n sea igual o inferior a 0.

La información de la función inicial se conserva de manera que cuando las funciones hijas terminen, pueda proseguir el curso de su ejecución. El sistema operativo crea un stack y hace push de toda la información de la función a ese stack cuando se produce una llamada a esa función. Si esa función hace una llamada a otra función, que puede ser ella misma mediante recursión, esta nueva función se pushea a la parte superior del stack, de manera que cuando termine su ejecución se hace pop y se elimina del stack, volviendo a quedar la función que la había llamado en la parte superior del stack y reanudando su ejecución. El código necesario para hacer push al stack es escrito por el compilador. En algunas ocasiones no es necesario crear un stack, esto ocurre cuando no hay más expresiones en la función madre después de la llamada a la función hija. Esto se debe a que no es necesario mantener la información de la función ya que no se va usar una vez la función hija termine. El stack se crea para almacenar la función caller mientras se ejecuta la hija y cuando la hija termina se hace pop, que devuelve la información de la función para que cntinúe su ejecución

###### TAIL RECURSION
Una función recursiva usa tail recursion si la llamada a sí misma ocurre como la última acción de la función. Es más eficiente ya que no hay actividad en el stack en la memoria y no es necesario perder tiempo llevando a cabo todas las operaciones push y pop

Recursión vs iteración: La recursión es equivalente a los bucles cuando se utiliza tail recursion, si no, los bucles son más eficientes.