---
title: 'Scope y closures'
description: 'Explicación de AWS Command Line Interface'
pubDate: 'Jul 01 2023'
heroImage: '/blog-placeholder-1.jpg'
---

El problema con var es que las variables pertenecen al objeto window o global y esto puede ser problemático porque se pueden reasignar variables presentes en estos objetos por error. Esto no ocurre con let y const, ya que estas variables no son añadidas al objeto global. Las variables con var siempre tienen un alcance goblal, sin importar que se definan dentro de un bloque. Los lenguajes con alcance dinámico son aquellos en los que el alcance de una variable depende de donde sea llamada y el contexto de ejecución. No es este el caso de javascript, donde el alcance es estático, esto significa, que el alcance de una variable es determinado en su declaración.

##### HOISTING
Permite usar funciones y variables antes de que se hayan declarado. Esto se debe a que el intérprete de JavaScript divide la declaración y asignación de funciones y variables. JavaScript mueve las declaraciones de las variables a la parte superior de su scope antes de la ejecución. Cuando el intérprete hace hoisting de una variable declarada con var, inicializa su valor a undefined. El uso de una variable no inicializada nunca mostrará un ReferenceError en lugar de un undefined. Las variables declaradas con let y const también reciben hoisting, pero no son inicializadas con un valor por defecto, las variables se mueven al inicio de su scope que no siempre es la parte más alta del archivo sino la parte más alta del bloque, por ejemplo el inicio de una función. Acceder a una variable declarada con let o const antes de que sea declarada resulta en un ReferenceError. La razón por la que se obtiene un error de referencia al intentar acceder a una variable declarada con let o const antes de su declaración se debe a la zona muerta temporal (TDZ). La TDZ comienza al principio del ámbito de la variable y finaliza cuando se declara. El acceso a la variable en esta zona TDZ lanza un ReferenceError. En resumen, con let y const, el hoisting también ocurre, pero javascript no permite acceder a esas variables hasta llegar a la lína de su declaración.

##### CLOSURES
Una closure es creada cuando una función se define dentro de otra función y esto permite a la función hija acceder a variables de la función padre, incluso después de que la función padre ha terminado su ejecución. Para que esto funcione, la función padre tiene que retornar la función hija. En la segunda imagen, cada vez que se ejecute nextId, el valor de count se incrementa en 1, el valor persiste a medida que se va llamando la función. Si se llama la función tres veces el valor de count será 4. Las closures son muy útiles para crear variables privadas. En vez de retornar una sola función que accede a la variable, se suele devolver un objeto con varias funciones. La variable sigue existiendo pero no se puede acceder a ella de manera directa, solo a través de la función que devuelve. Los closures sin un buen ejemplo de funciones que se llaman a si mismas de manera inmediata. Un uso típico de los closures es para guardar un estado que debe ser acturalizado mediante un evento listener sin tener que guardar una variable global.