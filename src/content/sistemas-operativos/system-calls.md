---
title: 'System calls'
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '/algoritmo.svg'
---

##### SYSTEM CALLS
Cuando se crea un archivo, por ejemplo de texto, se hace una llamada al sistema que ejecutará la función correspondiente, la cual dividirá el archivo en bloques y los guardará en el disco. A la hora de leer el archivo, se necesita una forma de saber en que bloque se encuentra, para no perder el tiempo recorriendo los millones de bloques buscándolo. Para ello se usan los directorios. Una vez que el archivo se coloca en los bloques, el programa filesystem crea un file control block en la RAM. Este bloque no es más que los atributos del archivo. Los directorios en el disco duro son tablas que contienen tuplas o registros, una por cada archivo presente en el ordenador. Las tuplas también tienen atributos, que son los mismos que los del file control block, uno de los más importantes es la localización, que indica el primer bloque en el que se encuentra el archivo. Además tienen un atributo extra que es el nombre. Otro atributo importante es el número de bloques, es importante para evitar que un proceso acceda a un bloque al que no tiene acceso. Por tanto se podría decir que un directorio es una colección de registros que contienen información sobre los archivos del disco. 

En C se puede hacer la llamada al sistema para que cree el archivo usando la función create(), recibiendo como parámetro el nombre que se le quiere dar al archivo. Debido a que el CPU no puede acceder directamente al disco duro, se copia el directorio a la RAM, donde se añade una nueva tupla referente al arhcivo que se acaba de crear y se actualizan los cambios en el bloque del directorio del disco duro.

Para calcular en qué bloque se encuentra un byte determinado lo que se hace es dividir el número lógico del byte entre el tamaño de los bloques, que suele ser 512 bytes y se redondea el resultado hacia abajo. Por ejemplo si se busca el byte lógico 1320, se realiza la operación 1320/512, que devuleve un cociente de 2,57. Esto significa que el el byte lógico número 1320 se encuentra en el tercer bloque, es decir en el número 2

La mayoría de las llamadas al sistema Unix devuelven un valor entero al final de la ejecución. Un 0 o un valor positivo indica un final correcto de la llamada. Un valor negativo (-1) indica un error en su ejecución. Cada llamada al sistema puede producir errores diferentes y variados. Para poder saber el error que ocurrió, cada proceso tiene una variable global llamada errno que describe el error que ocurrió después de cada llamada al sistema. Para controlar adecuadamente el comportamiento de un proceso, que utiliza llamadas al sistema, es completamente necesario realizar un seguimiento de la ejecución de cada llamada en detalle. Por este motivo, es totalmente aconsejable verificar el correcto final de la llamadas y, en caso contrario, detectar el error ocurrido.

El ID de grupo indica el grupo de procesos al que pertenece el proceso. Un proceso grupo es una agrupación de procesos que facilita la gestión conjunta de algunas funciones como el envío de señales (señal de llamada al sistema). El proceso de liderazgo del grupo es el que define el valor del ID del grupo, que será el mismo que su identificador de proceso (PID). Los grupos de procesos existen mientras aún existe cualquier proceso del grupo. 

Cada proceso pertenece al usuario que lo creó y cada usuario de Unix tiene una identificación única que lo representa. El ID de usuario será asignado al proceso en el momento de su creación y le otorgará un conjunto de derechos sobre los recursos del sistema. Cada proceso tendrá dos ID de usuario, el ID del usuario real y el ID de usuario efectivo.

El ID de usuario real nunca se modifica durante la vida del proceso y corresponde
al identificador del usuario que creó el proceso.

El UID efectivo se utiliza para la mayoría de las comprobaciones de acceso. También se utiliza como propietario de los archivos creados por ese proceso.  El sistema utiliza la ID de usuario efectiva para verificar los derechos del proceso sobre diferentes recursos del sistema. Al momento de crear un proceso, su ID de usuario efectivo coincide con el ID de usuario real, pero la ID de usuario efectiva se puede modificar durante toda la ejecución del proceso. Modificar el ID de usuario efectivo proporciona una herramienta importante para el acceso restringido de procesos de usuario a recursos del protegidos del sistema. 

El cambio de la ID de usuario efectiva puede ser causado por la ejecución (llamada al sistema exec) de un archivo ejecutable que tiene activo el bit llamado setUID (set-user-ID). Un claro ejemplo del uso de setUID se encuentra en el comando passwd. Este comando permite a cualquier usuario modificar su contraseña de acceso al sistema. Esta contraseña se almacena en un archivo (/etc/passwd) que es propiedad del usuario root  y que sólo este usuario puede modificar. También pertenece el archivo ejecutable con el comando passwd a root y tiene el bit setUID activo. Por lo tanto, cualquier proceso que ejecute este comando cambiará su ID de usuario efectivo que tomará como valor el ID del usuario root y, por tanto, podrá acceder al archivo de contraseñas (/etc/passwd) y modificarlo.

En Unix cabe destacar un estado particular que tienen algunos procesos después de su terminación: el estado zombie. Este estado corresponde a un proceso que no puede ser ejecutado nuevamente porque ya finalizó pero todavía está presente en el sistema porque no ha podido liberar todos sus recursos. La razón de la existencia del estado. Es un proceso que ha completado su ejecución pero aún tiene una entrada en la tabla de procesos, lo que permite al proceso que lo ha creado leer el estado de su salida.

Cada proceso es hijo de su proceso padre quien es responsable de liberar recursos de sus procesos secundarios en el momento de su finalización. Para liberar los procesos y eliminarlos completamente del sistema, el proceso padre debe estar sincronizado (wait) con el final (exit) de sus procesos secundarios. En este proceso de sincronización, el proceso hijo informa al padre de la causa de su terminación liberando todos sus recursos y desapareciendo del sistema. Si un proceso termina sin esta sincronización padre-hijo, el proceso pasa al estado zombie y permanecerá en este estado hasta que pueda liberar los recursos pendientes. Si el proceso padre desaparece sin sincronización con sus procesos secundarios, los procesos secundarios serán adoptados por el proceso init (proceso 1) y este proceso primogénito los liberará del estado zombie y desaparecerán del sistema.

El resultado de la ejecución de la call fork es la creación de un nuevo proceso, hijo del proceso creador que se ejecutará simultáneamente con el resto de procesos del sistema, que hereda muchas características de su padre. Cabe señalar, por ejemplo, que el nuevo proceso tiene el mismo código, los mismos datos, el misma stack y el mismo valor de contador de programa que el proceso creador. Esto no significa que comparten código y datos, sino que se crea un nuevo prhace return dos veces, primero en el proceso que la ha invocado y segundo, en el nuevo proceso que, como ya se mencionó, tiene el mismo código que el proceso creador y, por tanto, comenzará su ejecución justo después de que la función fork haya finalizado. En el padre, fork() devuelve el ID del proceso hijo y en el proceso hijo devuelve el valor 0. Es gracias a los diferentes valores de retorno que se puede distinguir entre padre e hijo. En caso de error devuelve -1.

Cuando se crea un proceso hijo, generalmente es para que haga cosas diferentes de las que hace su creador. La llamada al sistema exec permite cambiar todo el código, datos y stack de un proceso y cargar nuevo código y nuevos datos almacenados en un archivo ejecutable. Esta llamada es la que realmente permite ejecutar programas después de que se haya creado un nuevo proceso y por lo general, se utilizará inmediatamente después de fork. Una vez finalizado exec, el código del proceso que lo ha invocado habrá desaparecido por completo y, por lo tanto, la llamada nunca hará return de nada, es decir, los comandos del programa que puedan existir después de la llamada nunca se ejecutarán.

La familia exec de llamadas al sistema reemplaza el programa ejecutado por un proceso. Cuando un proceso llama a exec, todo el código (texto) y los datos del proceso se pierden y se reemplazan con el ejecutable del nuevo programa. La llamada devolverá el valor -1 en caso de error en su ejecución y la variable errno indicará el error que ocurrió. No se devuelve ningún valor si la llamada se
ejecuta correctamente, ya que la imagen del proceso que lo invoca es sobrescrita por la nueva imagen.

La función de la llamada exit es finalizar el proceso que la invoca. Si el proceso padre está ejecutando la llamada al sistema wait, se le notifica la terminación del hijo y el valor de los ocho bits menos significativos del parámetro se le pasa el estatus. Se envía una señal SIGCHLD a su padre, se libera toda la memoria asignada al proceso y los segmentos de memoria compartida de desasignan.  Si el proceso padre no está ejecutando la llamada wait cuando el proceso hijo invoque la llamada exit, entonces, el proceso que invoca exit se convierte en un proceso zombie.


La llamada wait bloquea el proceso que lo invoca hasta que esté disponible la información sobre el estado de terminación de alguno de sus hijos, o hasta que llegue una señal que tenga una función programada o que haga finalizar el proceso. Si la información sobre el estado final de cualquiera de sus hijos está disponible antes de invocar la llamada, la espera hará return inmediatamente. Si wait finaliza porque el estado final de un hijo está disponible, devolverá el ID del niño que finalizó. Si un proceso finaliza sin haber esperado (wait) el final de sus hijos, el identificador del proceso padre de todos sus hijos tomará el valor 1, es decir, sus procesos hijos son heredados por el proceso de inicialización (init) que se convierte en su padre.

Si el proceso hijo finaliza con la ejecución de la llamada de salida, los ocho bits menos significativos de la variable señalada por stat_loc tendrán un valor de 0 de los ocho bits más significativos contendrán el valor de los ocho bits menos significativos del argumento pasado a la salida de la llamada. Si el proceso hijo finaliza debido a una señal, los ocho bits más significativos de la variable señalada por stat_loc se borrarán y los ocho bits menos significativos contendrán el número de la señal que provocó que finalice el proceso. Si wait hace return debido al final de un proceso hijo, entonces la llamada devuelve el ID del proceso que finalizó. De lo contrario se devolverá el valor -1 y la variable errno indicará el error ocurrido.