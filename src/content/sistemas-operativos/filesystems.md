---
title: 'sistemas de archivos'
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '/algoritmo.svg'
---

Cualquier data o programa presente en el disco duro puede ser considerado como un archivo. Los discos duros se dividen en unidades llamadas bloques, el tamaño de los bloques difiere según la implementación aunque generalmente suele ser 512 bytes. Los archivos se dividen en bloques de archivo, cuyo tamaño es el mismo que el de los bloques del disco. Si el tamaño del archivo no es divisble entre el tamaño de los bloques del disco, en el último bloque usado para ese archivo quedará espacio vacío sin usar, que no puede ser usado para almacenar otros archivos (problema de fragmentación interna). Cada bloque solo puede contener un archivo, sin embargo, si el tamaño del archivo aumenta, ese espacio disponible si puede ser usado para esa nueva información. Si la distribución de bloques es contigua o no es decidido por el filesystem. Éste es un programa que se encarga de leer y escribir los archivos en el disco de la manera más eficiente posible. El filesystem es solo la parte de código o programa del sistema operativo que se encarga de manejar y estructurar los archivos, pero no los archivos en sí, aunque algunas veces se incluyen los archivos como oarte del filesystem, estrictamente hablando estos no forman parte de él, solo el código. Todo lo anterior se aplica a cualquier sistema de almacenamiento secundario incluido pen drives. 

La principal función del filesystem es asignar los bloques del disco a bloques de archivo, pero también llevar un seguimiento de qué bloques están vacíos. Para esto último, se pueden utilizar dos estructuras de datos, lista enlazada y mapa de bits. Un mapa de bit es un conjunto de bits alojados en la RAM que se corresponden con cada bloque del disco, de manera que el valor del bit dependerá de si el bloque asociado a ese bit está ocupado o no, 0 si está ocupado o 1 si está libre. En el caso de usar una lista enlazada, se coloca un puntero en los bloques vacíos apuntando al siguiente bloque vacío empezando por el primero hasta el último, cuyo puntero será NULL para señalar que no hay más bloques libres. La dirección del primer bloque libre se mantiene en la RAM, para que el filesystem pueda encontrarlo para poder asignar espacio. Cuando ese primer bloque es asignado, se actualiza la dirección al siguiente bloque, que ahora es el primero vacío y se elimina el puntero en el bloque asignado

Los archivos tienen una serie de atributos que son: nombre único, localización, tipo de archivo, tamaño, protección de información del archivo (por ejemplo para que los archivos servidos pr un servidor web no puedan ser modificados por los usuarios que acceden al servidor) y fecha. El conjunto de toda esta información se conoce como metadata. Al igual que las direcciones de la memoria RAM, aquí también hay números de bloque físicos y lógicos. Los físicos hacen referencia a la posición de los bloques dentro del disco. Los lógicos son los bloques en los que se divide el archivo, empezando por el 0. Dentro de los bloques la información se guarda en bytes, pero aunque el procesador siempre lee byte por byte (o palabra), no se puede leer un byte individual del disco duro, se debe mover el bloque entero a la RAM.

En Unic todo son archivos, tanto es así que en el directorio /proc se pueden encontrar directorios llamados como los id de los procesos activos con toda la información sobre estos como los fd, el stack, o enlaces al archivo ejecutable

El directorio /etc generalmente almacena archivos estñaticos de configuración, tanto de aplicaciones propias como de terceros.

##### ARCHIVOS EN UNIX
- Directorio: es un archivo que contiene referencias a otros archivos y es el elemento fundamental de la jerarquía de archivos Unix. Dentro de los archivos de directorio hay entradas que hacen match  del número de un inodo (el elemento que describe cada archivo) con el nombre (enlace) que se le proporciona al archivo en ese directorio.
- Archivo regular: es un archivo que contiene información general sin ninguna estructura específica.
- Dispositivo: es un archivo especial que representa cada uno de los dispositivos del sistema. Hay dos tipos: dispositivos de caracteres (por ejemplo terminales) y dispositivos de bloque (por ejemplo discos).
- Soft link: es un archivo que contiene el nombre de otro archivo que representa, de modo que acceder al enlace suave es como acceder al archivo al que enlaza.
- Canalizaciones con nombre: son dispositivos para la comunicación entre procesos.

Existe la posibilidad de que los archivos tengan más de un nombre (hard links). Incluso puede haber archivos que no tengan nombre y sean accesiblesy utilizables por los procesos que los han abierto. Gracias a esta característica, un archivo puede hacerse visible y accesible desde varios puntos del sistema de archivos. Esto es posible debido a la separación existente entre la información del archivo (inodo) y su nombre. Los inodos son estructuras que contienen toda la información de un archivo excepto su nombre y sus datos, que se almacenan en los bloques de datos del sistema de archivos. Dentro del inodo se encuentra información como:
- ID del propietario del archivo.
- ID del grupo de usuarios del archivo.
- Tamaño del archivo.
- Fecha de creación, fecha del último acceso y fecha de la última modificación.
- Tipo de archivo.
- Permisos de acceso para el usuario, grupo y otros usuarios.
- Número de nombres (enlaces físicos) del archivo.
- Punteros a bloques de datos.

El nombre del archivo se almacena dentro de los directorios. Cada entrada en un directorio es una asociación. entre un número de inodo y un nombre. De esta manera se pueden tener varios nombres  de cada archivo. Sólo se necesita asociar el mismo número de inodo (que representa el archivo) con diferentes nombres dentro de los directorios deseados.

La cantidad de nombres (enlaces físicos) de un archivo se almacenará en el inodo correspondiente y permitirá que el sistema operativo detecte cuando un archivo ya no tiene nombre y, por lo tanto, cuándo se puede eliminar un archivo del sistema. Sin embargo, el hecho de que un archivo
no tenga nombre no es condición suficiente para que desaparezca su inodo y la información que contiene. Para poder eliminar completamente un archivo es necesario, además de
al no tener nombre, que no haya ningún proceso que lo esté utilizando (archivo abierto).  Por lo tanto, es posible que un proceso tenga un archivo abierto, que borre su nombre y que siga trabajando con él sin que ningún otro proceso pueda acceder a él, ya que no tiene ningún nombre visible en el sistema de archivos. Esta forma de trabajar es común entre programas que utilizan archivos temporales durante la ejecución. En este caso, el archivo desaparece cuando
lo cierra el último proceso que lo tenía abierto.

Los enlaces simbólicos (soft links) son de un tipo especial de archivo utilizado para acceder a otro archivo desde cualquier parte del sistema de archivos. Los enlaces blandos contienen el nombre del archivo al que apuntan. Se diferencian en que los enlaces blandos son archivos, por el contrario, los enlaces físicos no son más que una entrada en un directorio que asocia un nombre con un número de inodo. 

Los enlaces blandos no son conocidos por el archivo que representan. A diferencia de los enlaces físicos, que se cuentan dentro del inodo de cada archivo, los enlaces suaves se crean y destruyen
sin que el archivo al que apuntaba lo supiera. Por esta razón, es posible que puede haber enlaces suaves que apunten a archivos inexistentes, porque el archivo señalado podría haber desaparecido del sistema después de la creación del enlace suave. Además, los enlaces blandos se pueden colocar en un sistema de archivos diferente al del archivo al que representan. Por el contrario, los enlaces duros (parejas “inodo - nombre” dentro de directorios) deben estar todos ubicados dentro del mismo sistema de archivos, para evitar ambigüedades con los números de inodo que coinciden entre diferentes sistemas de archivos.

Un descriptor de archivo es la abstracción de Unix para un flujo de entrada/salida abierto: un archivo, una conexión de red, una tubería (un canal de comunicación entre procesos), una terminal, etc. Los dispositivos (o canales) virtuales de Unix llamados descriptores de archivos se agrupan en una tabla separada para cada proceso. Cada dispositivo virtual se identifica con un valor en la tabla, de modo que el primer dispositivo virtual será el canal 0 y así sucesivamente. Las llamadas de lectura y escritura del sistema Unix utilizan exclusivamente dispositivos virtuales y, por tanto, son independientes de los dispositivos o archivos reales. que están asociados con cada descriptor de archivo. Para asociar dispositivos virtuales con un determinado dispositivo o archivo, se utiliza la llamada open. Para liberar un determinado dispositivo, la llamada al sistema utilizada es close. Por lo tanto, antes de poder utilizar un determinado dispositivo o archivo, es necesario abrirlo para asociar el dispositivo virtual con el archivo o dispositivo real. Una vez asociado el dispositivo virtual, se puede escribir o leer en este dispositivo virtual. Los dispositivos virtuales se heredan entre padres e hijos. De manera que los canales abiertos en el proceso padre también estén abiertos y apunten a los mismos dispositivos en el proceso hijo.

El método de descriptores de archivos permite asociar dinámicamente números enteros con canales de datos, de modo que un proceso pueda hacer referencia a ellos como sus flujos de datos de entrada/salida. Los procesos estándar de Linux tienen tres canales de comunicación abiertos de forma predeterminada: el canal de entrada estándar (stdin), el canal de salida estándar (stdout) y el canal de error estándar (stderr). Los descriptores de archivos numéricos asignados a estos canales son 0 para stdin, 1 para stdout y 2 para stderr. También se puede acceder a los canales de comunicación a través de los dispositivos especiales /dev/stdin, /dev/stdout y /dev/stderr.

Estos tres canales de comunicación estándar permiten a los programadores escribir código que lea y escriba datos sin preocuparse por el tipo de medio de donde proviene o hacia dónde se dirige. Por ejemplo, si un programa necesita un conjunto de datos como entrada, puede simplemente solicitar datos de la entrada estándar y cualquier cosa que se utilice como entrada estándar proporcionará esos datos. Asimismo, el método más sencillo que puede utilizar un programa para mostrar su salida  es escribirlo en la salida estándar. En una sesión de shell estándar, el teclado se define como stdin y la pantalla del monitor se define como stdout y stderr.

Cada canal se asocia a un dispositivo o archivo a través de una entrada en el llamada tabla open file. Esta tabla es global para todo el sistema y, por tanto, es la misma para todos los procesos. Esta tabla de archivos abiertos almacena, entre otras cosas, el puntero de lectura/escritura de los archivos abiertos. El puntero de lectura/escritura indica dónde se realizará la siguiente lectura o escritura en el archivo correspondiente. Al momento de abrir un archivo, el puntero de lectura/escritura se coloca al principio del archivo. Al leer o escribir en un archivo, el puntero avanza automáticamente tantas posiciones como bytes se hayan leído o escrito. El puntero también se puede modificar con una llamada al sistema específica para este propósito (lseek).

El motivo de la existencia de la tabla open file es no tener que ir a la tabla de directorios del disco duro cada vez a buscar el puntero que apunta a la direccion del bloque en el que se encuentra el archivo en cuestión. Esta información se copia en la tabla una vez que se ejecuta la llamada al sistema open. Debido a que múltiples procesos pueden acceder simultáneamente al mismo archivo, cada archivo tiene su propia tabla open file, con su file pointer correspondiente (marca donde se producirá la siguiente lectura o escritura), además cada entrada en esta tabla propia tiene un puntero a la entrada correspondiente de la tabla open file principal. Finalmente, la llamada call devuelve un puntero a la entrada de la tabla open file propia del proceso. Si otro proceso abre el mismo archivo su entrada en su tabla apuntará a la misma entrada de la tabla principal que el proceso anterior. La tabla principal también guarda la cantidad de procesos que tienen abierto el archivo, en el caso anterior serían dos. Cuando llegan a cero, la entrada de la tabla se borra

La tabla de file descriptors es una tabla que los procesos contienen en el PCB y que almacena punteros hacia recusrsos. Cuando un proceso abre o usa uno de esos recursos se crea una entrada en esta tabla. Cuando se crea el proceso, se crean de manera automática el 0, 1 y 2. Si un proceso, por ejemplo, crea un archivo, se crea un nuevo fd y se añade una entrada a la tabla, en este caso seraí la 4. A partir de entonces, ese fd se convierte en el manejador de ese archivo para ese proceso, de manera que se puede escribir en él usando la llamada al sistema write, usando este fd como argumento.

Cuando se hace fork, el proceso hijo es un proceso independiente y tiene su propia tabla de file descriptors, no obstante, el estado de las entradas de la tabla se hereda. Esto significa que si el padre ha leído, por ejemplo, los primeros 100 bytes del archivo anteriormente a la llamada fork, el puntero de localización apuntará a ese lugar en la entrada de la tabla para los dos procesos, de manera que si el hijo empieza a leer, lo hará empezando por ahí.


