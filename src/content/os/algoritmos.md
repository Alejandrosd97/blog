---
title: 'Algoritmos'
description: 'Lorem ipsum dolor sit amet'
pubDate: 'Jul 08 2022'
heroImage: '/algoritmo.svg'
---

Un shceduler es un programa que forma parte del sistema operativo que contiene el código que determina que proceso debe ejecutar el CPU en caso de que existan varios en ese momento necesitan acceso al procesador

Cada proceso tiene una serie de atributos propios. El primero es el ID. El segundo es el program counte (PC). Todos los procesos se ejecutarán, el scheduler simplemente decide el orden. El contador del programa es un registro donde se almacena la siguiente instrucción de un proceso que debe ser ejecutada. Sirve para recordar la instrucción por la que el proceso debe ser retomado en caso de que la ejecución del proceso se interrumpa debido a la aparición de otro proceso con mayor prioridad que necesite acceso inmediato al procesador. Una vez que este nuevo proceso termina, se retoma el proceso anterior desde el punto indicado en el programa del contador. Los registros de propósito general mantienen los valores previos a la interrupción para que sigan disponibles en el momento de la reanudación del programa interrumpido. Además del estado del proceso, otros atributos propios de los procesos son la lista de archivos abiertos y la lista de dispositivos abiertos. Atributo proteccion?????

###### ALGORITMOS DE SCHEDULING
La suma del bloque de control del proceso y los atributos forma el contexto del proceso.
Hay tres tipos de scheduler, el mencionado en la sección anterior es un Short time scheduler. El long time scheduler decide que programas, de los que se encuentran en new state en el disco duro son movidos a la RAM, ya que ésta tiene una capacidad limitada. Si no queda espacio libre en la RAM y uno de los procesos en new state tiene una prioridad mayor que los que ya están en la RAM, será movido a la RAM para que se ejecute primero y otro proceso con menor prioridad será movido al disco duro. Qué proceso es movido fuera de la RAM al área de swapp del disco duro para dejar espacio al proceso con mayor prioridad es decidiso por el medium term scheduler. Este proceso también se conoce como swapping. El más importante de los tres es el short time y a veces es referido como shceduler en general.

##### TIEMPOS DE LOS PROCESOS
El punto en el tiempo en el que el proceso es movido del disco duro a la RAM se conoce como arrival time. El tiempo que transcurre mientras un proceso no se está ejecutando en el CPU ni llevando a cabo operaciones de I/O se llama waiting time. El tiempo de completado es el momento en el que el proceso termina y es eliminado de la RAM. El tiempo de turn-around se calcula mediante la diferencia entre el tiempo de llegada y el tiempo de completado, es el tiempo que pasa un proceso dentro de la RAM. Este tiempo incluye el tiempo de espera del proceso en caso de interrupción por mayor prioridad de otro proceso. Tiempo de I/O es el tiempo empleado en una operación de I/O.

##### SCHEDULING ALGORITHMS
Existen dos tipos de algoritmos, preemptive algorithms y non-preemptive algorithms. En el caso de los non-preemptive, cuando un proceso inicia su ejecución en el CPU, ésta no se interrumpe aunque llegue a la RAM otro porceso con mayor prioridad. Cuando el proceso termina se comprueba cuál de los procesos restantes tiene mayor prioridad para ejecutarlo. Los algoritmos solo se aplican a los procesos que se encuentran en ready state, por mucha prioridad que que tenga un proceso, si se encuentra en I/O, estará bloqueado y no será tenido en cuenta por el algoritmo (por eso el estado I/O también recibe el nombre de block state)



###### ALGORITMO SJF (SHORTEST JOB FIRST)
Es un algoritmo non-preemptive que otorga preferencia a los procesos según su tiempo de ejecución. Es un algoritmo basado en la prioridad. Utiliza el tiempo de ejecución como parámetro para establecer la prioridad de los procesos

###### ALGORITMO SRTF (SHORTEST REMAINIG TIME FIRST)
Es la versión preemptive de SJF. Interrumpe la ejecución de un proceso cuando llega otro proceso con un tiempo de ejecución menor al tiempo de ejecución restante del proceso que se está ejecutando actualmente. Por ejemplo, suponiendo que el proceso en CPU tiene un tiempo de ejecución de 8ns. Transcurridos 2ns entra en la RAM otro proceso cuyo tiempo de ejecución es de 3ns. El shceduler interrumpirá la ejecución del primer proceso para ejcutar el segundo ya que su tiempo de ejecución (3ns) es menor que el tiempo de ejecución restante del primer proceso (6ns). En caso de que dos procesos tengan el mismo tiempo de ejecución, se ejecutará primero el que tenga un menor tiempo de llegada. Una vez que todos los procesos han llegado a la RAM y se encuentran en ready state, el algoritmo SRTF se comporta como SFJ

Throughput es la cantidad de procesos ejecutados por unidad de tiempo

###### FIRST COME FIRST SERVED (FCFS)
Es un algoritmo non-preemptive emdiante el cual el proceso con el menor tiempo de llegada es el que se ejecuta primero. En realidad no se está asignando ninguna prioridad a los procesos, simplemente se ejecutan por orden de llegada, por lo que se considera un algoritmo sin prioridad

###### TIEMPO DE RESPUESTA
Existe un tiempo de respuesta para cada proceso. Se define como el tiempo de espera hasta que llega al CPU por primera vez. Debido a que en los algoritmos non-preemptive no se interrumpen los procesos una vez han iniciado su ejecución en el procesador, el tiempo de resupuesta es el mismo que el tiempo de espera.


##### MEMORY ALLOCATION
El tamaño de word depende de la implementación. Cada palabra dentro de la memoria se corresponde con una dirección empezando por cero. La CPU y la RAM se comunican mediante un bus, que no es más una serie de cables usados para conectar los diferentes componentes del ordenador. El bus que comunica los registros y la RAM se compone de tres cables, uno para enviar la dirección, conocido como address bus

Sec conoce como address space a una colección de direcciones. El conjunto de direcciones de la RAM se conoce como physical address space. Dentro de la RAM se encuentran los procesos derivados de los programas que están en ejecución, y estos procesos también tienen direcciones, en este caso conocidas como direcciones lógicas. La colección de estas direcciones lógicas se conoce como logical address space. El termino allocation hace referencia al proceso de colocar los procesos dentro de la memoria. Existen dos tipos de allocation. 

El primer tipo es contiguous allocation, en este tipo, todas las direcciones lógicas de un proceso se corresponden con direcciones físicas contiguas en la memoria. El otro tipo es non-contiguous allocation, es este caso las direcciones lógias del proceso no se colocan en direcciones físicas contiguas dentro de la memoria. El tipo contiguo tiene a su vez dos subtipos. La RAM se divide en particiones dentro de cada cuál se colocará un proceso. En el primer tipo, que se llama de partición fija, estas particiones están establecidas de manera fija con un tamaño determinado y solo pueden contener un proceso. Este tipo se usaba antiguamente pero se encuentra en desuso en la actualidad debido a sus desventajas. La primera de ellas, es que presenta un problema de fragmentación interna, este problema ocurre cuando el proceso que se coloca dentro de la partición ocupa menos espacio del disponible dentro de la partición. El espacio restante no puede ser ocupado por otro proceso por lo que se desperdicia mucho espacio. El nivel de multiprogramming es igual al número de particiones. Un proceso no puede abarcar más de una partición, por lo que es tamaño máximo de un proceso está limitado por el tamaño de la partición más grande. Las particiones pueden ser del mismo tamaño o de tamaño variable, pero siempre fijas

En el tipo de partición variable, no se lleva a cabo ninguna prtición anter de colocar ningún proceso. Según se van colocando los procesos en la RAM se van creando las particiones con tamaño equivalente al del proceso. Debido a esto, evita los problemas presentes en el particionado fijo. No obstante sí tiene una desventaja, llamada fragmentación externa. Suponiendo que dos procesos en localizaciones no contiguas terminen y dejen su espacio libre, debido a que se está usando contiguous alocation, un proceso que ocupa un espacio equivalente a la suma del espacio dejado por los dos procesos que acaban de terminar no podrá ser alojado en ese espacio, es decir, no se puede partir el proceso y alojar cada parte en una de las dos particiones que han quedado libres. Este espacio quedará desperdiciado.


##### ALGORITMOS DE ALOJAMIENTO DE MEMORIA
A la hora de introducir un proceso en la RAM, lo primero es buscar un hueco en el quepueda caber un proceso. En caso de existir dicho hueco existen varias posibilidades para decidir en que lugar de la memoria alojar el proceso. En caso de usar el algoritmo first-fit, se aloja el proceso en el primer hueco disponible recorriendo la memoria desde el principio hasta el final. En el caso de best-fit, es necesario atravesar el address space entero de manera que el proceso es alojado en el hueco más pequeño capaz de acomodar el proceso. Best-fit optimiza la asignación del espacio, pero como contrapartida hace más lenta la asignación de memoria al necesitar recorrer toda la memoria, en comparación con first-fit y next-fit, donde existe la posibilidad de encontrar un hueco al inicio. El último algoritmo es worst-fit y funciona al revés que best-fit, es decir, recorre toda la memoria y elige el hueco más grande. El propósito de esto radica en que si un hueco ya de por sí es pequeño, al colocar el proceso en él, es espacio restante será aún más pequeño, por lo que es muy poco probable que ningún proceso futuro quepa ahí y quede sin usar. Con worst-fit, esto no ocurre. Los algoritmos se consideran como mejores o peores dependiendo de la cantidad de procesos que son capaces de son capaces de alojar en la memoria

##### PAGINACIÓN
Para solventar el problema de la fragmentación externa existen dos opciones. La primera es la compactación, que mueve la data de manera que desaparezcan los huecos en medio de las particiones ocupadas por procesos. Esto elimina por completo el problema de la fragmentación externa pero tiene su propia desventaja. Mover la información significa copiarla y pegarla en otra localización. Esto se realiza mediante código que debe ejecutar el procesador, de manera que en lugar de ejecutar el código de los procesos existentes en la RAM el CPU está ejecutando otro código para ir eliminando los huecos que se van ocasionando.

Para poder eliminar la fragmentación externa completamente sin la desventaja de la compactación se usa la paginación

A pesar de la desventaja de la fragmentación externa, el alojamiento contiguo tiene una ventaja importante.

Dentro del procesador existe un registro llamado base register, cuya función es almacenar la dirección base del proceso que quiere ejecutar, que es la dirección física donde empieza el proceso. El CPU siempre genera direcciones lógicas, independientemente de que dirección lógica sea la dirección base, para la primera instrucción del proceso el procesador generará la dirección 0, la cual se suma a la dirección base y será esta la que se buscará en la RAM. Suponiendo que la dirección base sea 50, se sumará la dirección lógica, 0 y se buscará la dirección 50 + 0 (50) en la RAM. Para la siguiente instrucción se genera la dirección lógica 1 y se suma a la base, por lo que sebuscará la dirección 51 en la RAM, y así sucesivamente. La razón por la que el CPU solo puede generar direcciones lógicas de debe a que no sabe dónde está cargado el proceso en la RAM. Por ello, todas las direcciones base de los procesos son almacenadas en una parte especial de la RAM, de manera que el procesador busca la dirección base del proceso a ejecutar y lo carga en el base register. Esta parte especial de la RAM está localizada en una parte fija de la memoria, para que el procesador sepa donde encontrarla. Esto es posible siempre que se use el alojamiento contiguo, ya que el procesador va incrementando las direcciones de uno en uno. Esta es la principal desventaja del alojamiento no contiguo, que el procesador no puede ejecutar procesos mediante adición simple. Es aquí donde entra en juego la paginación

La RAM se divide en bloques iguales llamados frames, y los procesos en bloques iguales llamados páginas, que siempre van a tener un tamaño igual al de los frames. Las páginas se alojan en diferentes frames de manera no contigua. Cada proceso tiene una tabla llamada tabla de páginas, donde cada fila indica en qué frame se encuentra presente cada página. Todo lo que se almacene en la RAM se divide en páginas, incluso la propia tabla, que también está almacenada en la memoria. Las tablas de páginas están almacenadas en una localización fija para que el CPU pueda encontrarlas

Se considera a un sistema como byte adressable system cuando cada dirección es asignada una dirección

Debido a que el tamaño del proceso debe ser un múltiplo del tamaño del frame, es posible tener fragmentación interna en la última página, por ejemplo si el tamaño de los frames son 4 bytes y el  del proceso son 15 bytes, se necesitan cuatro páginas, quedando la última con un byte libre. También es posible que se de fragmentación interna en el frame donde se guarde la página correspondiente a la tabla de páginas, si ésta no es muy extensa. Existe un registro llamado registro base de la dirección de la tabla que almacena la dirección base de la tabla de páginas para el proceso que se va a ejecutar.

Las direcciones lógicas generadas por el CPU se pueden dividir en dos partes, la primera hace referencia al número de página, mientras que el segundo al número de byte dentro de la página, conocido como offset de la página